// TODO: Generate the sphere using code.
// TODO: Make the position coordinates have a w coordinate.
// TODO: Use separate buffers for normals and positions.
// TODO: Create a function for each shape returning (VertexBuffer, IndexBuffer)

use wgpu::util::DeviceExt;

// TODO: Create a type that groups vertex, index buffers, and index count?
// This would reduce the number of fields for shapes, RenderMesh, etc.
// This should also make index count mismatches less frequent.
pub struct IndexedMeshBuffers {
    pub vertex_buffer: wgpu::Buffer,
    pub index_buffer: wgpu::Buffer,
    pub index_count: u32,
}

impl IndexedMeshBuffers {
    pub fn set<'a>(&'a self, pass: &mut wgpu::RenderPass<'a>) {
        pass.set_index_buffer(self.index_buffer.slice(..), wgpu::IndexFormat::Uint32);
        pass.set_vertex_buffer(0, self.vertex_buffer.slice(..));
    }

    fn from_vertices(device: &wgpu::Device, vertices: &[[f32; 4]], indices: &[u32]) -> Self {
        let vertex_buffer = device.create_buffer_init(&wgpu::util::BufferInitDescriptor {
            label: Some("Vertex Buffer"),
            contents: bytemuck::cast_slice(vertices),
            usage: wgpu::BufferUsages::VERTEX,
        });

        let index_buffer = device.create_buffer_init(&wgpu::util::BufferInitDescriptor {
            label: Some("Index Buffer"),
            contents: bytemuck::cast_slice(indices),
            usage: wgpu::BufferUsages::INDEX,
        });

        IndexedMeshBuffers {
            vertex_buffer,
            index_buffer,
            index_count: indices.len() as u32,
        }
    }
}

pub fn sphere_mesh_buffers(device: &wgpu::Device) -> IndexedMeshBuffers {
    IndexedMeshBuffers::from_vertices(device, &sphere_vertices(), &sphere_indices())
}

pub fn sphere_vertices() -> Vec<[f32; 4]> {
    // Pos0 Nrm0 Pos1 Nrm1 ...
    vec![
        [0.000000, 0.923880, -0.382683, 1.0],
        [0.000000, 0.923880, -0.382683, 1.0],
        [0.000000, 0.707107, -0.707107, 1.0],
        [0.000000, 0.707107, -0.707107, 1.0],
        [0.000000, 0.382683, -0.923880, 1.0],
        [0.000000, 0.382683, -0.923880, 1.0],
        [0.000000, -0.000000, -1.000000, 1.0],
        [0.000000, -0.000000, -1.000000, 1.0],
        [0.000000, -0.382683, -0.923880, 1.0],
        [0.000000, -0.382683, -0.923880, 1.0],
        [0.000000, -0.707107, -0.707107, 1.0],
        [0.000000, -0.707107, -0.707107, 1.0],
        [0.000000, -0.923880, -0.382683, 1.0],
        [0.000000, -0.923880, -0.382683, 1.0],
        [0.270598, 0.923880, -0.270598, 1.0],
        [0.270598, 0.923880, -0.270598, 1.0],
        [0.500000, 0.707107, -0.500000, 1.0],
        [0.500000, 0.707107, -0.500000, 1.0],
        [0.653282, 0.382683, -0.653281, 1.0],
        [0.653282, 0.382683, -0.653281, 1.0],
        [0.707107, -0.000000, -0.707107, 1.0],
        [0.707107, -0.000000, -0.707107, 1.0],
        [0.653282, -0.382683, -0.653282, 1.0],
        [0.653282, -0.382683, -0.653282, 1.0],
        [0.500000, -0.707107, -0.500000, 1.0],
        [0.500000, -0.707107, -0.500000, 1.0],
        [0.270598, -0.923880, -0.270598, 1.0],
        [0.270598, -0.923880, -0.270598, 1.0],
        [0.382684, 0.923880, 0.000000, 1.0],
        [0.382684, 0.923880, 0.000000, 1.0],
        [0.707107, 0.707107, 0.000000, 1.0],
        [0.707107, 0.707107, 0.000000, 1.0],
        [0.923880, 0.382683, 0.000000, 1.0],
        [0.923880, 0.382683, 0.000000, 1.0],
        [1.000000, -0.000000, 0.000000, 1.0],
        [1.000000, -0.000000, 0.000000, 1.0],
        [0.923880, -0.382683, 0.000000, 1.0],
        [0.923880, -0.382683, 0.000000, 1.0],
        [0.707107, -0.707107, 0.000000, 1.0],
        [0.707107, -0.707107, 0.000000, 1.0],
        [0.382684, -0.923880, 0.000000, 1.0],
        [0.382684, -0.923880, 0.000000, 1.0],
        [0.270598, 0.923880, 0.270598, 1.0],
        [0.270598, 0.923880, 0.270598, 1.0],
        [0.500000, 0.707107, 0.500000, 1.0],
        [0.500000, 0.707107, 0.500000, 1.0],
        [0.653282, 0.382683, 0.653282, 1.0],
        [0.653282, 0.382683, 0.653282, 1.0],
        [0.707107, -0.000000, 0.707107, 1.0],
        [0.707107, -0.000000, 0.707107, 1.0],
        [0.653282, -0.382683, 0.653282, 1.0],
        [0.653282, -0.382683, 0.653282, 1.0],
        [0.500000, -0.707107, 0.500000, 1.0],
        [0.500000, -0.707107, 0.500000, 1.0],
        [0.270598, -0.923880, 0.270598, 1.0],
        [0.270598, -0.923880, 0.270598, 1.0],
        [0.000000, 0.923880, 0.382684, 1.0],
        [0.000000, 0.923880, 0.382684, 1.0],
        [0.000000, 0.707107, 0.707107, 1.0],
        [0.000000, 0.707107, 0.707107, 1.0],
        [0.000000, 0.382683, 0.923880, 1.0],
        [0.000000, 0.382683, 0.923880, 1.0],
        [0.000000, -0.000000, 1.000000, 1.0],
        [0.000000, -0.000000, 1.000000, 1.0],
        [0.000000, -0.382683, 0.923880, 1.0],
        [0.000000, -0.382683, 0.923880, 1.0],
        [0.000000, -0.707107, 0.707107, 1.0],
        [0.000000, -0.707107, 0.707107, 1.0],
        [0.000000, -0.923880, 0.382684, 1.0],
        [0.000000, -0.923880, 0.382684, 1.0],
        [-0.000000, 1.000000, 0.000000, 1.0],
        [-0.000000, 1.000000, 0.000000, 1.0],
        [-0.270598, 0.923880, 0.270598, 1.0],
        [-0.270598, 0.923880, 0.270598, 1.0],
        [-0.500000, 0.707107, 0.500000, 1.0],
        [-0.500000, 0.707107, 0.500000, 1.0],
        [-0.653281, 0.382683, 0.653282, 1.0],
        [-0.653281, 0.382683, 0.653282, 1.0],
        [-0.707107, -0.000000, 0.707107, 1.0],
        [-0.707107, -0.000000, 0.707107, 1.0],
        [-0.653282, -0.382683, 0.653282, 1.0],
        [-0.653282, -0.382683, 0.653282, 1.0],
        [-0.500000, -0.707107, 0.500000, 1.0],
        [-0.500000, -0.707107, 0.500000, 1.0],
        [-0.270598, -0.923880, 0.270598, 1.0],
        [-0.270598, -0.923880, 0.270598, 1.0],
        [-0.382684, 0.923880, 0.000000, 1.0],
        [-0.382684, 0.923880, 0.000000, 1.0],
        [-0.707107, 0.707107, 0.000000, 1.0],
        [-0.707107, 0.707107, 0.000000, 1.0],
        [-0.923879, 0.382683, 0.000000, 1.0],
        [-0.923879, 0.382683, 0.000000, 1.0],
        [-1.000000, -0.000000, 0.000000, 1.0],
        [-1.000000, -0.000000, 0.000000, 1.0],
        [-0.923880, -0.382683, 0.000000, 1.0],
        [-0.923880, -0.382683, 0.000000, 1.0],
        [-0.707107, -0.707107, 0.000000, 1.0],
        [-0.707107, -0.707107, 0.000000, 1.0],
        [-0.382684, -0.923880, 0.000000, 1.0],
        [-0.382684, -0.923880, 0.000000, 1.0],
        [0.000000, -1.000000, 0.000000, 1.0],
        [0.000000, -1.000000, 0.000000, 1.0],
        [-0.270598, 0.923880, -0.270598, 1.0],
        [-0.270598, 0.923880, -0.270598, 1.0],
        [-0.500000, 0.707107, -0.500000, 1.0],
        [-0.500000, 0.707107, -0.500000, 1.0],
        [-0.653281, 0.382683, -0.653281, 1.0],
        [-0.653281, 0.382683, -0.653281, 1.0],
        [-0.707107, -0.000000, -0.707107, 1.0],
        [-0.707107, -0.000000, -0.707107, 1.0],
        [-0.653282, -0.382683, -0.653281, 1.0],
        [-0.653282, -0.382683, -0.653281, 1.0],
        [-0.500000, -0.707107, -0.500000, 1.0],
        [-0.500000, -0.707107, -0.500000, 1.0],
        [-0.270598, -0.923880, -0.270598, 1.0],
        [-0.270598, -0.923880, -0.270598, 1.0],
    ]
}

pub fn sphere_indices() -> Vec<u32> {
    vec![
        5, 13, 6, 3, 11, 4, 1, 9, 2, 0, 35, 7, 50, 6, 13, 4, 12, 5, 2, 10, 3, 0, 8, 1, 7, 35, 14,
        50, 13, 20, 11, 19, 12, 9, 17, 10, 7, 15, 8, 12, 20, 13, 11, 17, 18, 8, 16, 9, 19, 25, 26,
        16, 24, 17, 14, 22, 15, 19, 27, 20, 18, 24, 25, 15, 23, 16, 14, 35, 21, 50, 20, 27, 26, 34,
        27, 24, 32, 25, 22, 30, 23, 21, 35, 28, 50, 27, 34, 25, 33, 26, 23, 31, 24, 21, 29, 22, 31,
        40, 32, 29, 38, 30, 28, 35, 36, 50, 34, 42, 32, 41, 33, 30, 39, 31, 28, 37, 29, 34, 41, 42,
        50, 42, 49, 40, 48, 41, 38, 46, 39, 36, 44, 37, 42, 48, 49, 40, 46, 47, 38, 44, 45, 36, 35,
        43, 45, 54, 46, 43, 52, 44, 48, 57, 49, 46, 55, 47, 44, 53, 45, 43, 35, 51, 50, 49, 57, 47,
        56, 48, 56, 6, 57, 54, 4, 55, 52, 2, 53, 51, 35, 0, 50, 57, 6, 55, 5, 56, 54, 2, 3, 52, 0,
        1, 5, 12, 13, 3, 10, 11, 1, 8, 9, 4, 11, 12, 2, 9, 10, 0, 7, 8, 11, 18, 19, 9, 16, 17, 7,
        14, 15, 12, 19, 20, 11, 10, 17, 8, 15, 16, 19, 18, 25, 16, 23, 24, 14, 21, 22, 19, 26, 27,
        18, 17, 24, 15, 22, 23, 26, 33, 34, 24, 31, 32, 22, 29, 30, 25, 32, 33, 23, 30, 31, 21, 28,
        29, 31, 39, 40, 29, 37, 38, 32, 40, 41, 30, 38, 39, 28, 36, 37, 34, 33, 41, 40, 47, 48, 38,
        45, 46, 36, 43, 44, 42, 41, 48, 40, 39, 46, 38, 37, 44, 45, 53, 54, 43, 51, 52, 48, 56, 57,
        46, 54, 55, 44, 52, 53, 47, 55, 56, 56, 5, 6, 54, 3, 4, 52, 1, 2, 55, 4, 5, 54, 53, 2, 52,
        51, 0,
    ]
}

pub fn capsule_mesh_buffers(device: &wgpu::Device) -> IndexedMeshBuffers {
    IndexedMeshBuffers::from_vertices(device, &capsule_vertices(), &capsule_indices())
}

pub fn capsule_vertices() -> Vec<[f32; 4]> {
    // TODO: Properly handle the caps and connecting section.
    // Give each half a different W value to support two transform matrices.
    sphere_vertices()
        .into_iter()
        .map(|v| [v[0], v[1], v[2], 1.0])
        .chain(
            sphere_vertices()
                .into_iter()
                .map(|v| [v[0], v[1], v[2], 0.0]),
        )
        .collect()
}

pub fn capsule_indices() -> Vec<u32> {
    // TODO: Properly handle the caps and connecting section.
    let len1 = (sphere_vertices().len() / 2) as u32;
    sphere_indices()
        .into_iter()
        .chain(sphere_indices().into_iter().map(|i| i + len1))
        .collect()
}

pub fn plane_mesh_buffers(device: &wgpu::Device) -> IndexedMeshBuffers {
    IndexedMeshBuffers::from_vertices(device, &plane_vertices(), &plane_indices())
}

fn plane_vertices() -> Vec<[f32; 4]> {
    // The XY plane.
    // Pos0 Nrm0 Pos1 Nrm1 ...
    vec![
        [-1.0, 1.0, 0.0, 1.0],
        [0.0, 0.0, 1.0, 1.0],
        [1.0, 1.0, 0.0, 1.0],
        [0.0, 0.0, 1.0, 1.0],
        [-1.0, -1.0, 0.0, 1.0],
        [0.0, 0.0, 1.0, 1.0],
        [1.0, -1.0, 0.0, 1.0],
        [0.0, 0.0, 1.0, 1.0],
    ]
}

fn plane_indices() -> Vec<u32> {
    // TODO: Is this the correct winding order?
    vec![0, 1, 2, 2, 1, 3]
}
